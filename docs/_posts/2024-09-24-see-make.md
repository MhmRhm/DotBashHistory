---
layout: post
title: "SeeMake Template"
excerpt: "An in-depth manual for the SeeMake CMake template"
seo_description: "Discover how to use, customize, and integrate the SeeMake CMake template into your projects. Step-by-step guide by Mohammad Rahimi."
categories: 
  - CMake
  - Templates
tags:
  - CMake
  - Build Systems
  - Project Templates
author: "Mohammad Rahimi"
date: 2024-09-24
---

* Table of Contents
{:toc}

## Preface

Good software handles change smoothly and makes change easy.

There are various reasons you may need to update your codebase: a customer
requests an unexpected feature, an outdated dependency requires replacement, or
you want to support new platforms like macOS or the increasingly popular Windows
on ARM.

As your project evolves, it grows larger and more complex. You can manage this
complexity by breaking the project into smaller, manageable parts. At the core of
this process is your build system. A good build system not only supports growth
but also encourages best software development practices.

For C/C++ developers, CMake is an excellent build system. With proper use of
CMake, you can automate tasks like cross-platform development, testing,
documentation, and packaging for installation. Additionally, CMake is supported
by all major IDEs.

While this isn't a CMake tutorial, you can still learn a lot about it here. I
will walk you through different parts of the
[SeeMake](https://github.com/MhmRhm/SeeMake) template, explaining what each CMake
instruction is intended to achieve. This way, if you choose to use
[SeeMake](https://github.com/MhmRhm/SeeMake), you'll understand how to adapt it
for your own projects and needs.

Before continuing, ensure that you’ve completed the installation process as
explained [here](https://github.com/MhmRhm/SeeMake/blob/main/README.md).

## Directory Layout

If you check out the initial commit, you'll see the following folder structure
for this template:

```bash
git checkout $(git rev-list --max-parents=0 HEAD)
tree .
# .
# ├── benchmark
# │   ├── CMakeLists.txt
# │   ├── libsee
# │   │   └── CMakeLists.txt
# │   └── see
# │       └── CMakeLists.txt
# ├── cmake
# │   └── NoInSourceBuilds.cmake
# ├── CMakeLists.txt
# ├── LICENSE.txt
# ├── src
# │   ├── CMakeLists.txt
# │   ├── libsee
# │   │   └── CMakeLists.txt
# │   └── see
# │       └── CMakeLists.txt
# └── test
#     ├── CMakeLists.txt
#     ├── libsee
#     │   └── CMakeLists.txt
#     └── see
#         └── CMakeLists.txt
#
# 11 directories, 12 files
```

Here's a breakdown of each directory and its purpose:

- **root**: Contains the main `CMakeLists.txt` file, which serves as the entry
point for CMake. It references other `CMakeLists.txt` files in the subdirectories.
Later commits add a `CMakePresets.json` file, simplifying the build process with
presets for different configurations like debug and release. You can also create
platform-specific presets, each customized to use the appropriate compilers and
settings.

- **src**: This is where your application’s source code goes. You can organize
your code into smaller libraries and one executable, with each part placed in a
separate subdirectory under `src`.

- **test**: Automated tests are stored here, and typically, the test structure
mirrors that of `src`. This folder contains demo code for both Google Test and
Boost.Test.

- **benchmark**: Similar to how you monitor your code’s correctness in the `test`
directory, you can track its performance in `benchmark`. This folder includes a
demo using the Google Benchmark library.

- **cmake**: All supporting CMake files are placed here. These files include
instructions for automating tasks like tests, coverage reports, installation, and
packaging, which we will explore shortly.

You can use a CMake command to create a dependency graph for your project:

```bash
git checkout main
mkdir tmp
cd tmp/
cmake -S .. --preset linux-default-debug --graphviz=dependencies.dot
dot -Tpng -o dependencies.png dependencies.dot
```

The command `cmake -S .. --preset linux-default-debug --graphviz=dependencies.dot`
generates a dependency graph in Graphviz format.
- `-S ..`: Specifies the source directory, which is the parent directory in
this case.
- `--preset linux-default-debug`: Uses the predefined CMake preset for Linux
in debug mode.
- `--graphviz=dependencies.dot`: Outputs the dependency graph to a file named
`dependencies.dot`.

After running these commands, you should have a visual representation of your
project's dependencies.

<p align="center"><img src="https://i.postimg.cc/cL1HBF69/temp-Imagemfu5a-C.avif" alt="Dependency Graph"/></p>

## CMake Commands

After cloning the [SeeMake](https://github.com/MhmRhm/SeeMake) template, the
fastest way to build the library, executable, tests, and benchmarks is by running
a workflow. These workflows are defined in the `CMakePresets.json` file and can
be listed with the following command:

```bash
cmake --workflow --list-presets 
# Available workflow presets:
#
#   "linux-default-debug"     - Linux Debug
#   "linux-default-release"   - Linux Release
#   "windows-default-debug"   - Windows Debug
#   "windows-default-release" - Windows Release
#   "windows-x86-debug"       - Windows x86 Debug
#   "windows-x86-release"     - Windows x86 Release
#   "windows-clang-debug"     - Windows Clang Debug
#   "windows-clang-release"   - Windows Clang Release
#   "mac-default-debug"       - Mac Debug
#   "mac-default-release"     - Mac Release
```

Once you’ve chosen the appropriate workflow, run the following command:

```bash
cmake --workflow --preset linux-default-release
```

This command will build all artifacts, run the tests, and create an installer for
your software automatically.

Automatic generation of documentation, coverage reports, and dynamic checks are
defined as separate targets in CMake. For example, you can generate the
documentation by running the following command:

```bash
cmake --build --preset linux-default-release --target doxygen-libsee_static
```

To view the documentation, either serve the documentation folder using a Python
server or open the `index.html` file directly in your browser:

```bash
cd ../SeeMake-build-linux-default-release/doxygen-libsee_static/
python3 -m http.server 8172
# Visit localhost:8172 in your browser
```

To list all available targets, run the following command:

```bash
cmake --build --preset linux-default-release --target help
# The following are some of the valid targets for this Makefile:
# ... all (the default if no target is provided)
# ... clean
# ... coverage-google_test_libsee
# ... doxygen-libsee_static
# ... doxygen-terminal_see_static
# ... memcheck-google_test_libsee
# ... appsee
# ... google_bench_libsee
# ... google_bench_see
# ... google_test_libsee
# ... libsee_obj
# ... libsee_shared
# ... libsee_static
# ... terminal_see_static
```

To clean, configure, and build the project, run the following commands:

```bash
# Clean the project
cmake --build --preset linux-default-release --target clean

# Configure the project
cmake --preset linux-default-release

# Build the project
cmake --build --preset linux-default-release
```

To install the header files, static and shared libraries, and your executable,
run the following:

```bash
cmake --install ../SeeMake-build-linux-default-release/
tree ../SeeMake-install-linux-default-release/
# ../SeeMake-install-linux-default-release/
# ├── bin
# │   └── appsee
# ├── include
# │   └── libsee
# │       └── see_model.h
# └── lib
#     ├── cmake
#     │   └── libsee
#     │       ├── libsee-config.cmake
#     │       ├── libsee-config-version.cmake
#     │       ├── libsee-targets.cmake
#     │       └── libsee-targets-release.cmake
#     ├── libsee.a
#     └── libsee.so
```

By default, CMake installs artifacts in the root folder of your system. However,
in this case, the `CMakePresets.json` file defines the installation location to
be next to the build directory. If you want to install the artifacts in the root
directory on Linux, run the installation command as root and add the
`--prefix /usr` flag:

```bash
sudo cmake --install ../SeeMake-build-linux-default-release/ --prefix /usr
```

The following commands are used for packaging:

```bash
cpack --list-presets
# Available package presets:
#
#   "linux-deb"            - Linux DEB package
#   "windows-default-nsis" - Windows NSIS package
#   "windows-x86-nsis"     - Windows NSIS package for x86
#   "windows-clang-nsis"   - Windows NSIS package for Clang
```

To create a package, run the command:

```bash
cpack --preset linux-deb
# CPack: - package: /home/mohammad/repos/SeeMake-build-linux-default-release/package-linux-deb/SeeMake-0.0.0-Linux.deb generated.
```

## CMakePresets.json File

One of the key features that makes CMake portable and easy to use is
[Presets](https://cmake.org/cmake/help/latest/manual/cmake-presets.7.html). Many
IDEs, including VSCode, offer excellent support for them. Presets allow you to
define multiple configurations for tasks such as building, testing, and packaging.
You can also combine these into workflows for different environments.

In this section, I'll walk you through some of the presets defined in this
template, including debug and release builds for Linux, macOS, and Windows.

### Configure Presets

Before building your project, CMake sets up the build environment by generating
the appropriate build instructions, such as Makefiles or Visual Studio solutions.
The type of instructions generated depends on the Generator you choose. Two
generators used in this template are Ninja and Visual Studio.

Below is an example of a configure preset for Linux:

```json
{
	"name": "linux-default-release",
	"displayName": "Linux Release",
	"description": "Sets compilers, build and install directory, release build type",
	"binaryDir": "${sourceDir}/../${sourceDirName}-build-${presetName}",
	"condition": {
		"type": "equals",
		"lhs": "${hostSystemName}",
		"rhs": "Linux"
	},
	"cacheVariables": {
		"CMAKE_BUILD_TYPE": "Release",
		"CMAKE_CXX_STANDARD": "20",
		"CMAKE_CXX_STANDARD_REQUIRED": "YES",
		"CMAKE_CXX_EXTENSIONS": "OFF",
		"CMAKE_EXPORT_COMPILE_COMMANDS": "YES",
		"CMAKE_INSTALL_PREFIX": "${sourceDir}/../${sourceDirName}-install-${presetName}",
		"DEFAULT_CXX_COMPILE_FLAGS": "-Wextra;-Wall;-Wfloat-equal;-Wundef;-Wpointer-arith;-Wshadow;-Wcast-align;-Wswitch-default;-Wswitch-enum;-Wconversion;-Wpedantic;-Werror",
		"DEFAULT_CXX_OPTIMIZE_FLAG": "-O3"
	}
}
```

With the help of `cacheVariables`, you can customize various aspects of CMake,
such as compiler flags, installation directories, and the C++ standard. Some
`cacheVariables` used in other configure presets include the path to CppCheck
on Windows, as well as `WIN_MSVC` and `WIN_CLANG` to differentiate between the
two Windows presets. When `WIN_MSVC` is defined, dynamic checks are enabled on
Windows, whereas with `WIN_CLANG`, coverage reports are enabled. More details on
that will follow later.

In this template, In-Source Builds are disabled. Each preset specifies where the
project should be built, typically in a directory next to the template, named
`${sourceDirName}-build-${presetName}`.

### Build Presets

Each build preset is linked to a specific configuration preset. A build preset
can either build all targets or be assigned to a specific target. Below are two
examples of build presets:

```json
{
	"name": "windows-clang-debug",
	"jobs": 10,
	"displayName": "Windows Clang Debug",
	"description": "debug build type",
	"configurePreset": "windows-clang-debug",
	"configuration": "Debug"
},
{
	"name": "windows-clang-debug-doxygen",
	"hidden": true,
	"inherits": "windows-clang-debug",
	"targets": ["doxygen-libsee_static", "doxygen-terminal_see_static"]
}
```

The `windows-clang-debug-doxygen` preset inherits its properties from the
`windows-clang-debug` build preset and is also marked as hidden. A hidden preset
cannot be used directly in UI tools or from the command line, but it can still be
utilized as a step in workflows.

### Test Presets

The test presets in this template are quite simple:

```json
{
	"name": "mac-test-debug",
	"displayName": "Mac Test Debug",
	"description": "Tests the debug build type",
	"configurePreset": "mac-default-debug"
}
```

You can further customize these presets for more granularity, such as running a
specific subset of tests.

### Package Presets

Package presets run the CPack program, which in turn calls other programs to
create installers for your project. You can specify the programs CPack uses in
the `generators` list. Each generator requires its own configuration, with some
options being mandatory and most optional. A full list of available generators
and their configuration options can be found
[here](https://cmake.org/cmake/help/latest/manual/cpack-generators.7.html#manual:cpack-generators(7)).

```json
{
	"name": "linux-deb",
	"description": "linux deb packaging",
	"displayName": "Linux DEB",
	"configurePreset": "linux-default-release",
	"generators": ["DEB"],
	"configurations": ["Release"],
	"vendorName": "Mohammad Rahimi",
	"packageDirectory": "package-linux-deb",
	"environment": {
		"CPACK_DEBIAN_PACKAGE_NAME": "SeeMake",
		"CPACK_DEBIAN_FILE_NAME": "DEB-DEFAULT"
	}
},
{
	"name": "windows-nsis",
	"hidden": true,
	"generators": ["NSIS"],
	"configurations": ["Release"],
	"vendorName": "Mohammad Rahimi",
	"packageDirectory": "package-windows-nsis",
	"environment": {
		"CPACK_NSIS_DISPLAY_NAME": "SeeMake",
		"CPACK_NSIS_PACKAGE_NAME": "SeeMake",
		"CPACK_NSIS_URL_INFO_ABOUT": "https://github.com/MhmRhm"
	}
}
```

### Workflow Presets

With all the other presets in place, a workflow can combine them to automate your
pipeline:

```json
"workflowPresets": [
	{
		"name": "linux-default-debug",
		"displayName": "Linux Debug",
		"steps": [
			{
				"type": "configure",
				"name": "linux-default-debug"
			},
			{
				"type": "build",
				"name": "linux-default-debug"
			},
			{
				"type": "test",
				"name": "linux-test-debug"
			},
			{
				"type": "build",
				"name": "linux-default-debug-coverage"
			},
			{
				"type": "build",
				"name": "linux-default-debug-memcheck"
			},
			{
				"type": "build",
				"name": "linux-default-debug-doxygen"
			}
		]
	}
]
```

## CMakeLists.txt Files

The `CMakeLists.txt` file is the first file CMake looks for in a directory. From
there, you can include other directories and files in the project.

Anything included in the root `CMakeLists.txt` gets built. The main role of the
`CMakeLists.txt` file in the root directory of the template is to include other
directories and make helper CMake functions available for the targets. Most of
the actions take place in other CMake files. However, if you want to disable
building tests or benchmarks entirely, just comment out the relevant
`add_subdirectory` lines in this file:

```cmake
add_subdirectory(src bin)
# add_subdirectory(test)
# add_subdirectory(benchmark)
```

Let’s take a look at the `CMakeLists.txt` files that define the executable and
library targets. In `./src/libsee/`, we have defined the library targets.

```cmake
add_library(libsee_obj OBJECT
	see_model.cpp
)
add_library(libsee_shared SHARED)
add_library(libsee_static STATIC)
```

The `add_library` instruction creates a library target. Both shared and static
libraries are built from the object library:

```cmake
target_link_libraries(libsee_shared libsee_obj)
target_link_libraries(libsee_static libsee_obj)
```

CMake's Generator Expressions are used for adding header files to a target:

```cmake
target_include_directories(libsee_obj
	PUBLIC "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>"
	PUBLIC "$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>"
)
```

When building the project, the compiler looks for header files in the source
directory. When you install the libraries, others linking against them should
find the header files in the installation folder. Using these Generator
Expressions ensures that the CMake Config file generated contains the correct
paths. With the help of the Config file, others can use `find_package(libsee)` to
integrate your work into their project. See
[Relocatable Packages](https://cmake.org/cmake/help/latest/prop_tgt/INTERFACE_INCLUDE_DIRECTORIES.html#prop_tgt:INTERFACE_INCLUDE_DIRECTORIES)
and
[First Step](https://github.com/MhmRhm/SeeMake?tab=readme-ov-file#first-step).

To ensure your installation step moves the header files to the `include`
directory, you should add them to the `PUBLIC_HEADER` property and enable
`POSITION_INDEPENDENT_CODE`, so the virtual memory addresses are applied correctly
when the library is loaded into memory.

```cmake
set_target_properties(libsee_obj PROPERTIES
	PUBLIC_HEADER src/libsee/include/libsee/see_model.h
	POSITION_INDEPENDENT_CODE 1
)
```

Next, let’s look at the `CMakeLists.txt` in `./src/see`. This file defines two
targets. One of them contains only the `main()` function, which is called
bootstrapping. By placing everything our application needs to run in a separate
file (in this case, `terminal_see.cpp`) and reducing `main()` to a few function
calls or object creations, we can also test the code responsible for initializing
the application.

```cmake
add_library(terminal_see_static STATIC
	terminal_see.cpp
)
target_link_libraries(terminal_see_static
	PRIVATE precompiled
	PUBLIC libsee_static
)

add_executable(appsee main.cpp)
target_link_libraries(appsee
	PRIVATE precompiled
	PRIVATE terminal_see_static
)
```

When `terminal_see_static` links to `libsee_static`, all the header files in
`libsee_obj` become available to `terminal_see_static`. This is because of the
following instruction:

```cmake
target_include_directories(libsee_obj
	PUBLIC "$<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>"
	PUBLIC "$<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>"
)
```

By using `PUBLIC`, this target and anything that links to it inherit the property.
This is known as [Transitive Usage Requirements](https://cmake.org/cmake/help/latest/manual/cmake-buildsystem.7.html#target-usage-requirements)
in CMake.

Other `CMakeLists.txt` files are straightforward and simply define test and
benchmarking targets, linking them to the appropriate targets.

## .cmake Files

