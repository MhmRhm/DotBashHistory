---
layout: post
title: "SeeMake Template"
excerpt: "An in-depth manual for the SeeMake CMake template"
seo_description: "Discover how to use, customize, and integrate the SeeMake CMake template into your projects. Step-by-step guide by Mohammad Rahimi."
categories: 
  - CMake
  - Templates
tags:
  - CMake
  - Build Systems
  - Project Templates
author: "Mohammad Rahimi"
date: 2024-09-24
---

* Table of Contents
{:toc}

## Preface

Good software handles change smoothly and makes change easy.

There are various reasons you may need to update your codebase: a customer
requests an unexpected feature, an outdated dependency requires replacement, or
you want to support new platforms like macOS or the increasingly popular Windows
on ARM.

As your project evolves, it grows larger and more complex. You can manage this
complexity by breaking the project into smaller, manageable parts. At the core of
this process is your build system. A good build system not only supports growth
but also encourages best software development practices.

For C/C++ developers, CMake is an excellent build system. With proper use of
CMake, you can automate tasks like cross-platform development, testing,
documentation, and packaging for installation. Additionally, CMake is supported
by all major IDEs.

While this isn't a CMake tutorial, you can still learn a lot about it here. I
will walk you through different parts of the SeeMake template, explaining what
each CMake instruction is intended to achieve. This way, if you choose to use
SeeMake, you'll understand how to adapt it for your own projects and needs.

## Directory Layout

After checking out the initial commit, you'll see the following folder structure
for this template:

```bash
git checkout $(git rev-list --max-parents=0 HEAD)
tree .
# .
# ├── benchmark
# │   ├── CMakeLists.txt
# │   ├── libsee
# │   │   └── CMakeLists.txt
# │   └── see
# │       └── CMakeLists.txt
# ├── cmake
# │   └── NoInSourceBuilds.cmake
# ├── CMakeLists.txt
# ├── LICENSE.txt
# ├── src
# │   ├── CMakeLists.txt
# │   ├── libsee
# │   │   └── CMakeLists.txt
# │   └── see
# │       └── CMakeLists.txt
# └── test
#     ├── CMakeLists.txt
#     ├── libsee
#     │   └── CMakeLists.txt
#     └── see
#         └── CMakeLists.txt
#
# 11 directories, 12 files
```

Here's a breakdown of each directory and its purpose:

- **root**: Contains the main `CMakeLists.txt` file, which serves as the entry
point for CMake. It references other `CMakeLists.txt` files in the subdirectories.
Later commits add a `CMakePresets.json` file, simplifying the build process with
presets for different configurations like debug and release. You can also create
platform-specific presets, each customized to use the appropriate compilers and
settings.

- **src**: This is where your application’s source code goes. You can organize
your code into smaller libraries and one executable, with each part placed in a
separate subdirectory under `src`.

- **test**: Automated tests are stored here, and typically, the test structure
mirrors that of `src`. This folder contains demo code for both Google Test and
Boost.Test.

- **benchmark**: Similar to how you monitor your code’s correctness in the `test`
directory, you can track its performance in `benchmark`. This folder includes a
demo using the Google Benchmark library.

- **cmake**: All supporting CMake files are placed here. These files include
instructions for automating tasks like tests, coverage reports, installation, and
packaging, which we will explore shortly.

You can use a CMake command to create a dependency graph for your project:

```bash
git checkout main
mkdir tmp
cd tmp/
cmake -S .. --preset linux-default-debug --graphviz=dependencies.dot
dot -Tpng -o dependencies.png dependencies.dot
```

The command `cmake -S .. --preset linux-default-debug --graphviz=dependencies.dot`
generates a dependency graph in Graphviz format.
- `-S ..`: Specifies the source directory, which is the parent directory in
this case.
- `--preset linux-default-debug`: Uses the predefined CMake preset for Linux
in debug mode.
- `--graphviz=dependencies.dot`: Outputs the dependency graph to a file named
`dependencies.dot`.

After running these commands, you should have a visual representation of your
project's dependencies.

<p align="center"><img src="https://i.postimg.cc/cL1HBF69/temp-Imagemfu5a-C.avif" alt="Dependency Graph"/></p>

## CMake Commands


## CMakePresets.json File


## CMakeLists.txt Files


## .cmake Files

