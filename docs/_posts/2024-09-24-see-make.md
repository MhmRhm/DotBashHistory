---
layout: post
title: "SeeMake Template"
excerpt: "An in-depth manual for the SeeMake CMake template"
seo_description: "Discover how to use, customize, and integrate the SeeMake CMake template into your projects. Step-by-step guide by Mohammad Rahimi."
categories: 
  - CMake
  - Templates
tags:
  - CMake
  - Build Systems
  - Project Templates
author: "Mohammad Rahimi"
date: 2024-09-24
---

* Table of Contents
{:toc}

## Preface

Good software handles change smoothly and makes change easy.

There are various reasons you may need to update your codebase: a customer
requests an unexpected feature, an outdated dependency requires replacement, or
you want to support new platforms like macOS or the increasingly popular Windows
on ARM.

As your project evolves, it grows larger and more complex. You can manage this
complexity by breaking the project into smaller, manageable parts. At the core of
this process is your build system. A good build system not only supports growth
but also encourages best software development practices.

For C/C++ developers, CMake is an excellent build system. With proper use of
CMake, you can automate tasks like cross-platform development, testing,
documentation, and packaging for installation. Additionally, CMake is supported
by all major IDEs.

While this isn't a CMake tutorial, you can still learn a lot about it here. I
will walk you through different parts of the
[SeeMake](https://github.com/MhmRhm/SeeMake) template, explaining what each CMake
instruction is intended to achieve. This way, if you choose to use
[SeeMake](https://github.com/MhmRhm/SeeMake), you'll understand how to adapt it
for your own projects and needs.

Before continuing, ensure that you’ve completed the installation process as
explained [here](https://github.com/MhmRhm/SeeMake/blob/main/README.md).

## Directory Layout

If you check out the initial commit, you'll see the following folder structure
for this template:

```bash
git checkout $(git rev-list --max-parents=0 HEAD)
tree .
# .
# ├── benchmark
# │   ├── CMakeLists.txt
# │   ├── libsee
# │   │   └── CMakeLists.txt
# │   └── see
# │       └── CMakeLists.txt
# ├── cmake
# │   └── NoInSourceBuilds.cmake
# ├── CMakeLists.txt
# ├── LICENSE.txt
# ├── src
# │   ├── CMakeLists.txt
# │   ├── libsee
# │   │   └── CMakeLists.txt
# │   └── see
# │       └── CMakeLists.txt
# └── test
#     ├── CMakeLists.txt
#     ├── libsee
#     │   └── CMakeLists.txt
#     └── see
#         └── CMakeLists.txt
#
# 11 directories, 12 files
```

Here's a breakdown of each directory and its purpose:

- **root**: Contains the main `CMakeLists.txt` file, which serves as the entry
point for CMake. It references other `CMakeLists.txt` files in the subdirectories.
Later commits add a `CMakePresets.json` file, simplifying the build process with
presets for different configurations like debug and release. You can also create
platform-specific presets, each customized to use the appropriate compilers and
settings.

- **src**: This is where your application’s source code goes. You can organize
your code into smaller libraries and one executable, with each part placed in a
separate subdirectory under `src`.

- **test**: Automated tests are stored here, and typically, the test structure
mirrors that of `src`. This folder contains demo code for both Google Test and
Boost.Test.

- **benchmark**: Similar to how you monitor your code’s correctness in the `test`
directory, you can track its performance in `benchmark`. This folder includes a
demo using the Google Benchmark library.

- **cmake**: All supporting CMake files are placed here. These files include
instructions for automating tasks like tests, coverage reports, installation, and
packaging, which we will explore shortly.

You can use a CMake command to create a dependency graph for your project:

```bash
git checkout main
mkdir tmp
cd tmp/
cmake -S .. --preset linux-default-debug --graphviz=dependencies.dot
dot -Tpng -o dependencies.png dependencies.dot
```

The command `cmake -S .. --preset linux-default-debug --graphviz=dependencies.dot`
generates a dependency graph in Graphviz format.
- `-S ..`: Specifies the source directory, which is the parent directory in
this case.
- `--preset linux-default-debug`: Uses the predefined CMake preset for Linux
in debug mode.
- `--graphviz=dependencies.dot`: Outputs the dependency graph to a file named
`dependencies.dot`.

After running these commands, you should have a visual representation of your
project's dependencies.

<p align="center"><img src="https://i.postimg.cc/cL1HBF69/temp-Imagemfu5a-C.avif" alt="Dependency Graph"/></p>

## CMake Commands

After cloning the [SeeMake](https://github.com/MhmRhm/SeeMake) template, the
fastest way to build the library, executable, tests, and benchmarks is by running
a workflow. These workflows are defined in the `CMakePresets.json` file and can
be listed with the following command:

```bash
cmake --workflow --list-presets 
# Available workflow presets:
#
#   "linux-default-debug"     - Linux Debug
#   "linux-default-release"   - Linux Release
#   "windows-default-debug"   - Windows Debug
#   "windows-default-release" - Windows Release
#   "windows-x86-debug"       - Windows x86 Debug
#   "windows-x86-release"     - Windows x86 Release
#   "windows-clang-debug"     - Windows Clang Debug
#   "windows-clang-release"   - Windows Clang Release
#   "mac-default-debug"       - Mac Debug
#   "mac-default-release"     - Mac Release
```

Once you’ve chosen the appropriate workflow, run the following command:

```bash
cmake --workflow --preset linux-default-release
```

This command will build all artifacts, run the tests, and create an installer for
your software automatically.

Automatic generation of documentation, coverage reports, and dynamic checks are
defined as separate targets in CMake. For example, you can generate the
documentation by running the following command:

```bash
cmake --build --preset linux-default-release --target doxygen-libsee_static
```

To view the documentation, either serve the documentation folder using a Python
server or open the `index.html` file directly in your browser:

```bash
cd ../SeeMake-build-linux-default-release/doxygen-libsee_static/
python3 -m http.server 8172
# Visit localhost:8172 in your browser
```

To list all available targets, run the following command:

```bash
cmake --build --preset linux-default-release --target help
# The following are some of the valid targets for this Makefile:
# ... all (the default if no target is provided)
# ... clean
# ... coverage-google_test_libsee
# ... doxygen-libsee_static
# ... doxygen-terminal_see_static
# ... memcheck-google_test_libsee
# ... appsee
# ... google_bench_libsee
# ... google_bench_see
# ... google_test_libsee
# ... libsee_obj
# ... libsee_shared
# ... libsee_static
# ... terminal_see_static
```

To clean, configure, and build the project, run the following commands:

```bash
# Clean the project
cmake --build --preset linux-default-release --target clean

# Configure the project
cmake --preset linux-default-release

# Build the project
cmake --build --preset linux-default-release
```

To install the header files, static and shared libraries, and your executable,
run the following:

```bash
cmake --install ../SeeMake-build-linux-default-release/
tree ../SeeMake-install-linux-default-release/
# ../SeeMake-install-linux-default-release/
# ├── bin
# │   └── appsee
# ├── include
# │   └── libsee
# │       └── see_model.h
# └── lib
#     ├── cmake
#     │   └── libsee
#     │       ├── libsee-config.cmake
#     │       ├── libsee-config-version.cmake
#     │       ├── libsee-targets.cmake
#     │       └── libsee-targets-release.cmake
#     ├── libsee.a
#     └── libsee.so
```

By default, CMake installs artifacts in the root folder of your system. However,
in this case, the `CMakePresets.json` file defines the installation location to
be next to the build directory. If you want to install the artifacts in the root
directory on Linux, run the installation command as root and add the
`--prefix /usr` flag:

```bash
sudo cmake --install ../SeeMake-build-linux-default-release/ --prefix /usr
```

The following commands are used for packaging:

```bash
cpack --list-presets
# Available package presets:
#
#   "linux-deb"            - Linux DEB package
#   "windows-default-nsis" - Windows NSIS package
#   "windows-x86-nsis"     - Windows NSIS package for x86
#   "windows-clang-nsis"   - Windows NSIS package for Clang
```

To create a package, run the command:

```bash
cpack --preset linux-deb
# ...
# CPack: - package: /home/mohammad/repos/SeeMake-build-linux-default-release/package-linux-deb/SeeMake-0.0.0-Linux.deb generated.
```

## CMakePresets.json File


## CMakeLists.txt Files


## .cmake Files

